// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BTLOGGER_BT_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_BTLOGGER_BT_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"

namespace BT_Serialization {

struct Timestamp;

struct TreeNode;

struct BehaviorTree;

struct Status;

struct StatusChange;

struct StatusChangeLog;

enum class Status : int8_t {
  IDLE = 0,
  RUNNING = 1,
  SUCCESS = 2,
  FAILURE = 3,
  MIN = IDLE,
  MAX = FAILURE
};

inline const Status (&EnumValuesStatus())[4] {
  static const Status values[] = {
    Status::IDLE,
    Status::RUNNING,
    Status::SUCCESS,
    Status::FAILURE
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[] = {
    "IDLE",
    "RUNNING",
    "SUCCESS",
    "FAILURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesStatus()[index];
}

enum class NodeType : int8_t {
  UNDEFINED = 0,
  ACTION = 1,
  CONDITION = 2,
  CONTROL = 3,
  DECORATOR = 4,
  SUBTREE = 5,
  MIN = UNDEFINED,
  MAX = SUBTREE
};

inline const NodeType (&EnumValuesNodeType())[6] {
  static const NodeType values[] = {
    NodeType::UNDEFINED,
    NodeType::ACTION,
    NodeType::CONDITION,
    NodeType::CONTROL,
    NodeType::DECORATOR,
    NodeType::SUBTREE
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[] = {
    "UNDEFINED",
    "ACTION",
    "CONDITION",
    "CONTROL",
    "DECORATOR",
    "SUBTREE",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesNodeType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Timestamp FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t sec_;
  uint32_t usec_;

 public:
  Timestamp() {
    memset(this, 0, sizeof(Timestamp));
  }
  Timestamp(uint32_t _sec, uint32_t _usec)
      : sec_(flatbuffers::EndianScalar(_sec)),
        usec_(flatbuffers::EndianScalar(_usec)) {
  }
  uint32_t sec() const {
    return flatbuffers::EndianScalar(sec_);
  }
  uint32_t usec() const {
    return flatbuffers::EndianScalar(usec_);
  }
};
FLATBUFFERS_STRUCT_END(Timestamp, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Status FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t uid_;
  int8_t status_;
  int8_t padding0__;

 public:
  Status() {
    memset(this, 0, sizeof(Status));
  }
  Status(uint16_t _uid, Status _status)
      : uid_(flatbuffers::EndianScalar(_uid)),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        padding0__(0) {
    (void)padding0__;
  }
  uint16_t uid() const {
    return flatbuffers::EndianScalar(uid_);
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
};
FLATBUFFERS_STRUCT_END(Status, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) StatusChange FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t uid_;
  int8_t prev_status_;
  int8_t status_;
  uint32_t usec_delta_;

 public:
  StatusChange() {
    memset(this, 0, sizeof(StatusChange));
  }
  StatusChange(uint16_t _uid, Status _prev_status, Status _status, uint32_t _usec_delta)
      : uid_(flatbuffers::EndianScalar(_uid)),
        prev_status_(flatbuffers::EndianScalar(static_cast<int8_t>(_prev_status))),
        status_(flatbuffers::EndianScalar(static_cast<int8_t>(_status))),
        usec_delta_(flatbuffers::EndianScalar(_usec_delta)) {
  }
  uint16_t uid() const {
    return flatbuffers::EndianScalar(uid_);
  }
  Status prev_status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(prev_status_));
  }
  Status status() const {
    return static_cast<Status>(flatbuffers::EndianScalar(status_));
  }
  uint32_t usec_delta() const {
    return flatbuffers::EndianScalar(usec_delta_);
  }
};
FLATBUFFERS_STRUCT_END(StatusChange, 8);

struct TreeNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UID = 4,
    VT_PAREND_UID = 6,
    VT_TYPE = 8,
    VT_NAME = 10
  };
  uint16_t uid() const {
    return GetField<uint16_t>(VT_UID, 0);
  }
  uint16_t parend_uid() const {
    return GetField<uint16_t>(VT_PAREND_UID, 0);
  }
  NodeType type() const {
    return static_cast<NodeType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_UID) &&
           VerifyField<uint16_t>(verifier, VT_PAREND_UID) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct TreeNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(uint16_t uid) {
    fbb_.AddElement<uint16_t>(TreeNode::VT_UID, uid, 0);
  }
  void add_parend_uid(uint16_t parend_uid) {
    fbb_.AddElement<uint16_t>(TreeNode::VT_PAREND_UID, parend_uid, 0);
  }
  void add_type(NodeType type) {
    fbb_.AddElement<int8_t>(TreeNode::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TreeNode::VT_NAME, name);
  }
  explicit TreeNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TreeNodeBuilder &operator=(const TreeNodeBuilder &);
  flatbuffers::Offset<TreeNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TreeNode>(end);
    fbb_.Required(o, TreeNode::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<TreeNode> CreateTreeNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t uid = 0,
    uint16_t parend_uid = 0,
    NodeType type = NodeType::UNDEFINED,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  TreeNodeBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_parend_uid(parend_uid);
  builder_.add_uid(uid);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TreeNode> CreateTreeNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t uid = 0,
    uint16_t parend_uid = 0,
    NodeType type = NodeType::UNDEFINED,
    const char *name = nullptr) {
  return BT_Serialization::CreateTreeNode(
      _fbb,
      uid,
      parend_uid,
      type,
      name ? _fbb.CreateString(name) : 0);
}

struct BehaviorTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROOT_UID = 4,
    VT_NODES = 6
  };
  uint16_t root_uid() const {
    return GetField<uint16_t>(VT_ROOT_UID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TreeNode>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TreeNode>> *>(VT_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ROOT_UID) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.Verify(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           verifier.EndTable();
  }
};

struct BehaviorTreeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_root_uid(uint16_t root_uid) {
    fbb_.AddElement<uint16_t>(BehaviorTree::VT_ROOT_UID, root_uid, 0);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TreeNode>>> nodes) {
    fbb_.AddOffset(BehaviorTree::VT_NODES, nodes);
  }
  explicit BehaviorTreeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BehaviorTreeBuilder &operator=(const BehaviorTreeBuilder &);
  flatbuffers::Offset<BehaviorTree> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BehaviorTree>(end);
    return o;
  }
};

inline flatbuffers::Offset<BehaviorTree> CreateBehaviorTree(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t root_uid = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TreeNode>>> nodes = 0) {
  BehaviorTreeBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  builder_.add_root_uid(root_uid);
  return builder_.Finish();
}

inline flatbuffers::Offset<BehaviorTree> CreateBehaviorTreeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t root_uid = 0,
    const std::vector<flatbuffers::Offset<TreeNode>> *nodes = nullptr) {
  return BT_Serialization::CreateBehaviorTree(
      _fbb,
      root_uid,
      nodes ? _fbb.CreateVector<flatbuffers::Offset<TreeNode>>(*nodes) : 0);
}

struct StatusChangeLog FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BEHAVIOR_TREE = 4,
    VT_INITIAL_STATUS = 6,
    VT_INITIAL_TIME = 8,
    VT_STATE_CHANGES = 10
  };
  const BehaviorTree *behavior_tree() const {
    return GetPointer<const BehaviorTree *>(VT_BEHAVIOR_TREE);
  }
  const flatbuffers::Vector<int8_t> *initial_status() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_INITIAL_STATUS);
  }
  const Timestamp *initial_time() const {
    return GetStruct<const Timestamp *>(VT_INITIAL_TIME);
  }
  const flatbuffers::Vector<const StatusChange *> *state_changes() const {
    return GetPointer<const flatbuffers::Vector<const StatusChange *> *>(VT_STATE_CHANGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BEHAVIOR_TREE) &&
           verifier.VerifyTable(behavior_tree()) &&
           VerifyOffset(verifier, VT_INITIAL_STATUS) &&
           verifier.Verify(initial_status()) &&
           VerifyField<Timestamp>(verifier, VT_INITIAL_TIME) &&
           VerifyOffset(verifier, VT_STATE_CHANGES) &&
           verifier.Verify(state_changes()) &&
           verifier.EndTable();
  }
};

struct StatusChangeLogBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_behavior_tree(flatbuffers::Offset<BehaviorTree> behavior_tree) {
    fbb_.AddOffset(StatusChangeLog::VT_BEHAVIOR_TREE, behavior_tree);
  }
  void add_initial_status(flatbuffers::Offset<flatbuffers::Vector<int8_t>> initial_status) {
    fbb_.AddOffset(StatusChangeLog::VT_INITIAL_STATUS, initial_status);
  }
  void add_initial_time(const Timestamp *initial_time) {
    fbb_.AddStruct(StatusChangeLog::VT_INITIAL_TIME, initial_time);
  }
  void add_state_changes(flatbuffers::Offset<flatbuffers::Vector<const StatusChange *>> state_changes) {
    fbb_.AddOffset(StatusChangeLog::VT_STATE_CHANGES, state_changes);
  }
  explicit StatusChangeLogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatusChangeLogBuilder &operator=(const StatusChangeLogBuilder &);
  flatbuffers::Offset<StatusChangeLog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusChangeLog>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusChangeLog> CreateStatusChangeLog(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<BehaviorTree> behavior_tree = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> initial_status = 0,
    const Timestamp *initial_time = 0,
    flatbuffers::Offset<flatbuffers::Vector<const StatusChange *>> state_changes = 0) {
  StatusChangeLogBuilder builder_(_fbb);
  builder_.add_state_changes(state_changes);
  builder_.add_initial_time(initial_time);
  builder_.add_initial_status(initial_status);
  builder_.add_behavior_tree(behavior_tree);
  return builder_.Finish();
}

inline flatbuffers::Offset<StatusChangeLog> CreateStatusChangeLogDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<BehaviorTree> behavior_tree = 0,
    const std::vector<int8_t> *initial_status = nullptr,
    const Timestamp *initial_time = 0,
    const std::vector<StatusChange> *state_changes = nullptr) {
  return BT_Serialization::CreateStatusChangeLog(
      _fbb,
      behavior_tree,
      initial_status ? _fbb.CreateVector<int8_t>(*initial_status) : 0,
      initial_time,
      state_changes ? _fbb.CreateVectorOfStructs<StatusChange>(*state_changes) : 0);
}

inline const BT_Serialization::StatusChangeLog *GetStatusChangeLog(const void *buf) {
  return flatbuffers::GetRoot<BT_Serialization::StatusChangeLog>(buf);
}

inline const BT_Serialization::StatusChangeLog *GetSizePrefixedStatusChangeLog(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<BT_Serialization::StatusChangeLog>(buf);
}

inline bool VerifyStatusChangeLogBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<BT_Serialization::StatusChangeLog>(nullptr);
}

inline bool VerifySizePrefixedStatusChangeLogBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<BT_Serialization::StatusChangeLog>(nullptr);
}

inline void FinishStatusChangeLogBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<BT_Serialization::StatusChangeLog> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedStatusChangeLogBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<BT_Serialization::StatusChangeLog> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace BT_Serialization

#endif  // FLATBUFFERS_GENERATED_BTLOGGER_BT_SERIALIZATION_H_
